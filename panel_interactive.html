<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>부산 미분양 민감도 지도 (HTML + JS)</title>

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 16px;
    }
    h1 {
      font-size: 20px;
      margin-bottom: 8px;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      margin-bottom: 12px;
      font-size: 14px;
    }
    select, label {
      font-size: 14px;
    }
    #map {
      width: 100%;
      height: 600px;
      border: 1px solid #ddd;
    }
    .legend {
      background: white;
      padding: 6px 8px;
      font-size: 12px;
      line-height: 1.4;
      border-radius: 3px;
      box-shadow: 0 0 5px rgba(0,0,0,0.2);
    }
    .legend-title {
      font-weight: 600;
      margin-bottom: 4px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 2px;
    }
    .legend-color {
      width: 14px;
      height: 14px;
      margin-right: 4px;
      border-radius: 2px;
      border: 1px solid #999;
    }
  </style>
</head>
<body>
  <h1>부산 미분양 민감도 지도 (변수별)</h1>

  <div class="controls">
    <div>
      <label for="varSelect">변수 선택:</label>
      <select id="varSelect"></select>
    </div>
    <div>
      <label>
        <input type="checkbox" id="showOnlySig" checked />
        유의한 구만 색칠 (sig == 1)
      </label>
    </div>
  </div>

  <div id="map"></div>

  <!-- Leaflet JS -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <script>
    // ===== 설정: CSV / GeoJSON 경로 =====
    const CSV_PATH = "summary_table_full.csv";            // 네 CSV 파일
    const GEOJSON_PATH = "data/busan_gu.geojson";    // Python에서 쓰던 경로 기준

    // ===== 전역 데이터 =====
    let coefRows = [];        // CSV 전체
    let guGeojson = null;     // 부산 구 경계
    let map = null;
    let geoLayer = null;

    const varSelect = document.getElementById("varSelect");
    const showOnlySig = document.getElementById("showOnlySig");

    // ===== CSV 파서 (간단 버전: 콤마 기준 split) =====
    function parseCsv(text) {
      const lines = text.trim().split(/\r?\n/);
      const header = lines[0].split(",");
      const rows = [];

      for (let i = 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;
        const cols = line.split(",");
        if (cols.length < 6) continue;

        rows.push({
          variable: cols[0],
          region: cols[1],
          slope: parseFloat(cols[2]),   // 기울기
          pvalue: parseFloat(cols[3]),
          sig: parseInt(cols[4], 10),   // CSV에 이미 p값 기준으로 찍혀 있음
          dev: parseFloat(cols[5])      // 평균 대비 편차
        });
      }
      return rows;
    }

    // ===== 색상 보간 헬퍼 (hex 색상 linear interpolation) =====
    function hexToRgb(hex) {
      const h = hex.replace("#", "");
      return {
        r: parseInt(h.substring(0, 2), 16),
        g: parseInt(h.substring(2, 4), 16),
        b: parseInt(h.substring(4, 6), 16),
      };
    }

    function rgbToHex(r, g, b) {
      const toHex = (v) => v.toString(16).padStart(2, "0");
      return "#" + toHex(r) + toHex(g) + toHex(b);
    }

    function interpolateColor(c1, c2, t) {
      const a = hexToRgb(c1);
      const b = hexToRgb(c2);
      const r = Math.round(a.r + (b.r - a.r) * t);
      const g = Math.round(a.g + (b.g - a.g) * t);
      const b2 = Math.round(a.b + (b.b - a.b) * t);
      return rgbToHex(r, g, b2);
    }

    // Folium에서 쓰던 팔레트 비슷하게:
    // 음수: green(#1a9850) -> white(#ffffff)
    // 양수: white(#ffffff) -> red(#d73027)
    function slopeToColor(slope, maxAbs) {
      if (maxAbs <= 0) return "#ffffff";
      const x = Math.max(-maxAbs, Math.min(maxAbs, slope)); // [-maxAbs, maxAbs]
      if (x === 0) return "#ffffff";

      if (x < 0) {
        // 음수: green → white
        const t = (x + maxAbs) / maxAbs; // x=-maxAbs → 0, x=0 → 1
        return interpolateColor("#1a9850", "#ffffff", t);
      } else {
        // 양수: white → red
        const t = x / maxAbs;           // x=0 → 0, x=maxAbs → 1
        return interpolateColor("#ffffff", "#d73027", t);
      }
    }

    // ===== 변수 목록 채우기 =====
    function initVarSelect() {
      const vars = Array.from(new Set(coefRows.map(r => r.variable)));
      vars.forEach(v => {
        const opt = document.createElement("option");
        opt.value = v;
        opt.textContent = v;
        varSelect.appendChild(opt);
      });
      if (vars.length > 0) {
        varSelect.value = vars[0];
      }
    }

    // ===== 선택된 변수 + sig 조건에 따른 슬라이스 =====
    function getCurrentVarRows() {
      const v = varSelect.value;
      let rows = coefRows.filter(r => r.variable === v);
      if (showOnlySig.checked) {
        rows = rows.filter(r => r.sig === 1);
      }
      return rows;
    }

    // ===== 지도 스타일링 =====
    function styleFeatureFactory(varName) {
      const rows = getCurrentVarRows();
      // region → row 매핑
      const byRegion = {};
      rows.forEach(r => {
        byRegion[r.region] = r;
      });

      // sig=1인 구만으로 scale 잡기
      const sigRows = coefRows.filter(
        r => r.variable === varName && r.sig === 1
      );
      let maxAbs = 1.0;
      if (sigRows.length > 0) {
        maxAbs = Math.max(...sigRows.map(r => Math.abs(r.slope)));
      }

      return function style(feature) {
        const name = feature.properties.sggnm; // geojson의 구 이름 필드와 맞추기
        const row = byRegion[name];

        // CSV에 해당 구가 없으면 테두리만
        if (!row) {
          return {
            fillColor: "#00000000",
            color: "#555555",
            weight: 0.5,
            fillOpacity: 0.0
          };
        }

        // 비유의(sig=0)일 때 표시 방식:
        //  - 유의한 구만 보기 체크 시: 완전 투명 (히든 느낌)
        //  - 아니면 회색
        if (row.sig !== 1) {
          if (showOnlySig.checked) {
            return {
              fillColor: "#00000000",
              color: "#999999",
              weight: 0.5,
              fillOpacity: 0.0
            };
          }
          return {
            fillColor: "#666666",
            color: "#333333",
            weight: 0.5,
            fillOpacity: 0.6
          };
        }

        // sig==1인 유의한 구: slope 기반 색 지정
        const color = slopeToColor(row.slope, maxAbs);

        return {
          fillColor: color,
          color: "#333333",
          weight: 0.6,
          fillOpacity: 0.85
        };
      };
    }

    // ===== 툴팁/팝업 =====
    function onEachFeatureFactory() {
      const rows = getCurrentVarRows();
      const byRegionAll = {};
      coefRows.forEach(r => {
        if (!byRegionAll[r.variable]) byRegionAll[r.variable] = {};
        byRegionAll[r.variable][r.region] = r;
      });

      return function onEachFeature(feature, layer) {
        const name = feature.properties.sggnm;
        const varName = varSelect.value;
        const row = byRegionAll[varName] ? byRegionAll[varName][name] : null;

        if (!row) {
          layer.bindTooltip(name, {sticky: true});
          return;
        }

        const html =
          `<div><b>${name}</b></div>` +
          `<div>variable: ${row.variable}</div>` +
          `<div>기울기: ${row.slope.toFixed(6)}</div>` +
          `<div>p-value: ${row.pvalue.toExponential(2)}</div>` +
          `<div>sig: ${row.sig}</div>` +
          `<div>평균 대비 편차: ${row.dev.toFixed(6)}</div>`;

        layer.bindTooltip(html, {sticky: true});
      };
    }

    // ===== 지도 다시 그리기 =====
    function redrawMapLayer() {
      if (!map || !guGeojson) return;
      if (geoLayer) {
        geoLayer.removeFrom(map);
      }

      const varName = varSelect.value;
      const styleFn = styleFeatureFactory(varName);
      const onEachFn = onEachFeatureFactory();

      geoLayer = L.geoJSON(guGeojson, {
        style: styleFn,
        onEachFeature: onEachFn
      }).addTo(map);
    }

    // ===== 범례 추가 =====
    function addLegend() {
      const legend = L.control({ position: "bottomright" });

      legend.onAdd = function () {
        const div = L.DomUtil.create("div", "legend");
        div.innerHTML =
          `<div class="legend-title">색상 의미</div>
           <div class="legend-item">
             <div class="legend-color" style="background:#1a9850;"></div>
             <span>음의 기울기 (미분양 감소 방향)</span>
           </div>
           <div class="legend-item">
             <div class="legend-color" style="background:#ffffff;"></div>
             <span>0에 가까움</span>
           </div>
           <div class="legend-item">
             <div class="legend-color" style="background:#d73027;"></div>
             <span>양의 기울기 (미분양 증가 방향)</span>
           </div>
           <div class="legend-item">
             <div class="legend-color" style="background:#666666;"></div>
             <span>비유의(sig=0)</span>
           </div>`;
        return div;
      };

      legend.addTo(map);
    }

    // ===== 초기화: 지도 생성 + 데이터 로딩 =====
    function initMap() {
      map = L.map("map").setView([35.1796, 129.0756], 11);

      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 18,
        attribution: "&copy; OpenStreetMap"
      }).addTo(map);

      addLegend();
    }

    function init() {
      initMap();

      Promise.all([
        fetch(CSV_PATH).then(res => {
          if (!res.ok) throw new Error("CSV 로드 실패");
          return res.text();
        }),
        fetch(GEOJSON_PATH).then(res => {
          if (!res.ok) throw new Error("GeoJSON 로드 실패");
          return res.json();
        })
      ]).then(([csvText, geojson]) => {
        coefRows = parseCsv(csvText);   // CSV → 배열
        guGeojson = geojson;           // GeoJSON 보관

        initVarSelect();
        redrawMapLayer();
      }).catch(err => {
        console.error(err);
        alert("데이터 로딩 중 오류 발생: " + err.message);
      });
    }

    // 이벤트
    varSelect.addEventListener("change", redrawMapLayer);
    showOnlySig.addEventListener("change", redrawMapLayer);

    // 시작
    init();
  </script>
</body>
</html>
